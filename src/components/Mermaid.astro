---
// src/components/Mermaid.astro
// å®Œæ•´äº¤äº’ç‰ˆï¼šä¸»ç•Œé¢æ»šåŠ¨æ¡ + Ctrlç¼©æ”¾(zoom) + åŒå‡»å…¨å±
// å…¨å±ï¼šæ‹–æ‹½å¹³ç§» + Ctrlç¼©æ”¾(transform)
---

<script>
  const isDark = document.documentElement.classList.contains("dark");
  console.log("isDark =", isDark);

  import mermaid from "mermaid";

  mermaid.initialize({
    startOnLoad: false,
    theme: isDark ? "dark" : "default",
    securityLevel: "loose",

    flowchart: {
      htmlLabels: true,
      fontSize: 14,
    },
    sequence: { fontSize: 14 },
    gantt: { fontSize: 14 },
    class: { fontSize: 14 },
    state: { fontSize: 14 },
    er: { fontSize: 14 },
    pie: { textPosition: 0.5, fontSize: 14 },

    themeVariables: {
      fontSize: "14px",
      fontFamily: "Arial, sans-serif",
    },
  });

function forceSvgOverflow(div) {
  const wrapper = div.querySelector(".mermaid-interactive-wrapper");
  const svg = div.querySelector(".mermaid-interactive-wrapper svg");
  if (!wrapper || !svg) return;

  // å…ˆè®©å®ƒè‡ªé€‚åº”ï¼ˆä¸æº¢å‡ºï¼‰
  svg.style.width = "100%";
  svg.style.maxWidth = "100%";
  svg.style.height = "auto";
  svg.style.display = "block";

  requestAnimationFrame(() => {
    const bbox = svg.getBBox();
    const realWidth = Math.ceil(bbox.width + 100);
    const wrapperWidth = wrapper.clientWidth;

    // âœ… è¶…å‡ºæ‰æ’‘å¼€ -> è§¦å‘æ»šåŠ¨æ¡
    if (realWidth > wrapperWidth) {
      svg.style.width = `${realWidth}px`;
      svg.style.maxWidth = "none";
      wrapper.classList.add("has-scroll");
    } else {
      wrapper.classList.remove("has-scroll");
    }
  });
}




  function extractMermaidText(container) {
    const code = container.querySelector("code");
    if (code) {
      let text = (code.innerText || code.textContent || "").trim();
      return cleanMermaidText(text);
    }

    const lines = container.querySelectorAll('[class*="line"]:not([class*="number"])');
    if (lines.length > 0) {
      const text = Array.from(lines)
        .map((line) => {
          const clone = line.cloneNode(true);
          clone.querySelectorAll('[class*="number"], .line-number, .ln').forEach((el) => el.remove());
          return (clone.innerText || clone.textContent || "").trim();
        })
        .filter((line) => line.length > 0)
        .join("\n");

      return cleanMermaidText(text);
    }

    let text = (container.innerText || container.textContent || "").trim();
    return cleanMermaidText(text);
  }

  function cleanMermaidText(text) {
    const lines = text.split("\n");
    const cleanedLines = [];

    for (let line of lines) {
      line = line.trim();
      if (/^\d+$/.test(line)) continue;
      line = line.replace(/^\d+\s+/, "");
      if (line.length > 0) cleanedLines.push(line);
    }

    const result = cleanedLines.join("\n").trim();
    console.log("[Mermaid] After cleaning:", result);
    return result;
  }

  function findMermaidBlocks() {
    const results = [];

    document.querySelectorAll("pre").forEach((pre) => {
      const code = pre.querySelector("code");
      const cls = (code?.className || pre.className || "").toLowerCase();
      if (cls.includes("mermaid")) {
        results.push(pre);
      }
    });

    document.querySelectorAll("figure, div.expressive-code, [class*='astro-code']").forEach((box) => {
      const hasMermaidLabel = Array.from(box.querySelectorAll("*")).some((n) => {
        const text = (n.textContent || "").trim().toUpperCase();
        return text === "MERMAID";
      });

      if (hasMermaidLabel) {
        results.push(box);
      }
    });

    document.querySelectorAll('[data-language="mermaid"]').forEach((el) => {
      const container = el.closest("figure, div, pre") || el;
      results.push(container);
    });

    return Array.from(new Set(results));
  }

  // åˆ›å»ºæ¨¡æ€æ¡†
  function createModal() {
    if (document.getElementById("mermaid-modal")) return;

    const modal = document.createElement("div");
    modal.id = "mermaid-modal";
    modal.className = "mermaid-modal";
    modal.innerHTML = `
      <div class="mermaid-modal-overlay"></div>
      <div class="mermaid-modal-content">
        <button class="mermaid-modal-close" aria-label="å…³é—­">Ã—</button>
        <div class="mermaid-modal-controls">
          <button class="mermaid-zoom-btn" data-action="zoom-in" title="æ”¾å¤§">ğŸ”+</button>
          <button class="mermaid-zoom-btn" data-action="zoom-out" title="ç¼©å°">ğŸ”-</button>
          <button class="mermaid-zoom-btn" data-action="reset" title="é‡ç½®">â†º</button>
          <span class="mermaid-zoom-level">100%</span>
        </div>
        <div class="mermaid-modal-body"></div>
      </div>
    `;
    document.body.appendChild(modal);

    const closeBtn = modal.querySelector(".mermaid-modal-close");
    const overlay = modal.querySelector(".mermaid-modal-overlay");

    const closeModal = () => {
      modal.classList.remove("active");
      document.body.style.overflow = "";
    };

    closeBtn?.addEventListener("click", closeModal);
    overlay?.addEventListener("click", closeModal);

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && modal.classList.contains("active")) {
        closeModal();
      }
    });
  }

  // æ›´æ–°ç¼©æ”¾æ¯”ä¾‹æ˜¾ç¤º
  function updateZoomDisplay(container, scale) {
    const zoomLevel = container.closest(".mermaid-modal")?.querySelector(".mermaid-zoom-level");
    if (zoomLevel) {
      zoomLevel.textContent = `${Math.round(scale * 100)}%`;
    }
  }

  // âœ… ä¸»ç•Œé¢æ»šåŠ¨æ¡ç¼©æ”¾ï¼ˆä½¿ç”¨ zoomï¼Œä¿è¯ overflow-x ç”Ÿæ•ˆï¼‰
  function makeScrollableZoom(wrapper, content) {
    let scale = 1;

    const applyZoom = () => {
      scale = Math.min(Math.max(scale, 0.5), 3); // âœ… ä¸»ç•Œé¢ç¼©æ”¾èŒƒå›´
      content.style.zoom = String(scale);
    };

    wrapper.addEventListener(
      "wheel",
      (e) => {
        if (!e.ctrlKey && !e.metaKey) return;
        e.preventDefault();

        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        scale += delta;
        applyZoom();
      },
      { passive: false }
    );

    applyZoom();
  }

  // âœ… å…¨å±äº¤äº’ï¼šæ‹–æ‹½ + transform ç¼©æ”¾
  function makeInteractive(wrapper, options = { enableDrag: true }) {
    let scale = 1;
    let translateX = 0;
    let translateY = 0;
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let lastTranslateX = 0;
    let lastTranslateY = 0;

    const svg = wrapper.querySelector("svg");
    if (!svg) return;

    const applyTransform = () => {
      svg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
      svg.style.transformOrigin = "0 0";
      svg.style.transition = isDragging ? "none" : "transform 0.15s ease";
    };

    // âœ… æ‹–æ‹½ï¼ˆå¯é€‰ï¼‰
    if (options.enableDrag) {
      wrapper.addEventListener("mousedown", (e) => {
        if (e.button !== 0) return;

        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        lastTranslateX = translateX;
        lastTranslateY = translateY;
        wrapper.style.cursor = "grabbing";
        e.preventDefault();
      });

      document.addEventListener("mousemove", (e) => {
        if (!isDragging) return;

        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;

        translateX = lastTranslateX + deltaX;
        translateY = lastTranslateY + deltaY;

        applyTransform();
      });

      document.addEventListener("mouseup", () => {
        if (isDragging) {
          isDragging = false;
          wrapper.style.cursor = "grab";
        }
      });
    }

    // Ctrl + æ»šè½®ç¼©æ”¾ï¼ˆå…¨å±ï¼‰
    wrapper.addEventListener(
      "wheel",
      (e) => {
        if (!e.ctrlKey && !e.metaKey) return;

        e.preventDefault();

        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        const newScale = Math.min(Math.max(0.3, scale + delta), 5);

        // ä»¥é¼ æ ‡ä½ç½®ä¸ºä¸­å¿ƒç¼©æ”¾
        const rect = wrapper.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const scaleChange = newScale / scale;
        translateX = mouseX - (mouseX - translateX) * scaleChange;
        translateY = mouseY - (mouseY - translateY) * scaleChange;

        scale = newScale;
        applyTransform();

        updateZoomDisplay(wrapper, scale);
      },
      { passive: false }
    );

    wrapper.style.cursor = options.enableDrag ? "grab" : "default";
    wrapper.style.overflow = "hidden";
    applyTransform();

    return {
      get scale() {
        return scale;
      },
      set scale(v) {
        scale = v;
      },
      get translateX() {
        return translateX;
      },
      set translateX(v) {
        translateX = v;
      },
      get translateY() {
        return translateY;
      },
      set translateY(v) {
        translateY = v;
      },
      applyTransform,
    };
  }

  // ä¸ºæ™®é€šè§†å›¾æ·»åŠ äº¤äº’
  function addInteractiveFeature(mermaidDiv) {
    const wrapper = document.createElement("div");
    wrapper.className = "mermaid-interactive-wrapper";

    const content = document.createElement("div");
    content.className = "mermaid-interactive-content";

    content.innerHTML = mermaidDiv.innerHTML;
    mermaidDiv.innerHTML = "";

    wrapper.appendChild(content);
    mermaidDiv.appendChild(wrapper);

    const hint = document.createElement("div");
    hint.className = "mermaid-hint";
    mermaidDiv.appendChild(hint);

    // âœ… ä¸»ç•Œé¢ï¼šæ»šåŠ¨æ¡ç¼©æ”¾ï¼ˆzoomï¼‰
    makeScrollableZoom(wrapper, content);

    // åŒå‡»å…¨å±
    content.addEventListener("dblclick", () => {
      openFullscreen(mermaidDiv);
    });
  }

  // æ‰“å¼€å…¨å±æ¨¡æ€æ¡†
  function openFullscreen(mermaidDiv) {
    const modal = document.getElementById("mermaid-modal");
    const modalBody = modal?.querySelector(".mermaid-modal-body");

    if (!modal || !modalBody) return;

    const svg = mermaidDiv.querySelector("svg");
    if (!svg) return;

    // å…‹éš† SVG åˆ°æ¨¡æ€æ¡†
    const clonedSvg = svg.cloneNode(true);
    modalBody.innerHTML = "";
    modalBody.appendChild(clonedSvg);

    const transform = makeInteractive(modalBody, { enableDrag: true });

    const zoomIn = modal.querySelector('[data-action="zoom-in"]');
    const zoomOut = modal.querySelector('[data-action="zoom-out"]');
    const reset = modal.querySelector('[data-action="reset"]');

    zoomIn?.addEventListener("click", () => {
      const newScale = Math.min(transform.scale + 0.2, 5);
      transform.scale = newScale;
      transform.applyTransform();
      updateZoomDisplay(modalBody, newScale);
    });

    zoomOut?.addEventListener("click", () => {
      const newScale = Math.max(transform.scale - 0.2, 0.3);
      transform.scale = newScale;
      transform.applyTransform();
      updateZoomDisplay(modalBody, newScale);
    });

    reset?.addEventListener("click", () => {
      transform.scale = 1;
      transform.translateX = 0;
      transform.translateY = 0;
      transform.applyTransform();
      updateZoomDisplay(modalBody, 1);
    });

    modal.classList.add("active");
    document.body.style.overflow = "hidden";
    updateZoomDisplay(modalBody, 1);
  }

  async function renderMermaid() {
    const blocks = findMermaidBlocks();
    console.log("[Mermaid] Found blocks:", blocks.length);

    let converted = 0;

    for (const container of blocks) {
      try {
        const text = extractMermaidText(container);

        const isMermaid =
          text.includes("graph") ||
          text.includes("sequenceDiagram") ||
          text.includes("classDiagram") ||
          text.includes("stateDiagram") ||
          text.includes("erDiagram") ||
          text.includes("journey") ||
          text.includes("gantt") ||
          text.includes("pie") ||
          text.includes("flowchart");

        if (!isMermaid) continue;

        const div = document.createElement("div");
        div.className = "mermaid mermaid-container";
        div.textContent = text;

        container.replaceWith(div);
        converted++;
      } catch (e) {
        console.error("[Mermaid] Error processing block:", e);
      }
    }

    console.log("[Mermaid] Converted:", converted);

    if (converted > 0) {
      try {
        await mermaid.run({ querySelector: ".mermaid" });
        console.log("[Mermaid] Rendered âœ…");

        createModal();

        document.querySelectorAll(".mermaid-container").forEach((div) => {
          if (!div.querySelector(".mermaid-interactive-wrapper")) {
            addInteractiveFeature(div);
          }

          // âœ… å¼ºåˆ¶è®© SVG äº§ç”Ÿæº¢å‡º -> æ¨ªå‘æ»šåŠ¨æ¡å¿…å‡ºç°
          forceSvgOverflow(div);
        });
      } catch (e) {
        console.error("[Mermaid] Render failed âŒ", e);
      }
    }
  }

  // åˆå§‹æ¸²æŸ“
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMermaid);
  } else {
    renderMermaid();
  }

  // Swup æ”¯æŒ
  if (window.swup) {
    window.swup.hooks.on("page:view", renderMermaid);
  }
  document.addEventListener("swup:page:view", renderMermaid);
</script>

<style is:global>
  /* åŸºç¡€å®¹å™¨ */
  .mermaid-container {
    width: 100%;
    margin: 2rem 0;
    position: relative;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    padding: 1rem;
    background: #f8fafc;
  }

  :global(.dark) .mermaid-container {
    border-color: #374151;
    background: #1f2937;
  }

  /* âœ… ä¸»ç•Œé¢æ»šåŠ¨å®¹å™¨ï¼šæ¨ªå‘æ»šåŠ¨æ¡ */
  .mermaid-interactive-wrapper {
    width: 100%;
    overflow-x: auto;
    overflow-y: hidden;
    position: relative;
    border-radius: 4px;
    background: white;
    scrollbar-width: thin;
  }

  :global(.dark) .mermaid-interactive-wrapper {
    background: #111827;
  }

  /* âœ… å†…å®¹å®¹å™¨å¿…é¡»ç”±å†…å®¹æ’‘å¼€ï¼Œå¦åˆ™ä¸ä¼šæº¢å‡º -> æ²¡æ»šåŠ¨æ¡ */
  .mermaid-interactive-content {
    display: inline-block;
    width: max-content;
    height: auto;
  }

  .mermaid-interactive-content svg {
    display: block;
    max-width: none !important;
    height: auto !important;
  }

  /* âœ… å¼ºåˆ¶ Mermaid å­—ä½“ 10~14ï¼Œå½»åº•æ¶ˆç­èš‚èšå­— */
  .mermaid svg text,
  .mermaid svg tspan,
  .mermaid svg .nodeLabel,
  .mermaid svg .edgeLabel,
  .mermaid svg .label {
    font-size: clamp(10px, 1em, 14px) !important;
    font-family: Arial, sans-serif !important;
  }

  /* æç¤ºæ–‡å­— */
  .mermaid-hint {
    text-align: center;
    font-size: 0.875rem;
    color: #64748b;
    margin-top: 1rem;
    padding: 0.5rem;
    background: #f1f5f9;
    border-radius: 4px;
  }

  .mermaid-hint strong {
    color: #475569;
    font-weight: 600;
  }

  :global(.dark) .mermaid-hint {
    color: #94a3b8;
    background: #334155;
  }

  :global(.dark) .mermaid-hint strong {
    color: #cbd5e1;
  }

  /* æ¨¡æ€æ¡† */
  .mermaid-modal {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 9999;
    align-items: center;
    justify-content: center;
  }

  .mermaid-modal.active {
    display: flex;
  }

  .mermaid-modal-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(4px);
  }

  .mermaid-modal-content {
    position: relative;
    width: 95vw;
    height: 95vh;
    background: white;
    border-radius: 12px;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    z-index: 1;
  }

  :global(.dark) .mermaid-modal-content {
    background: #1f2937;
  }

  /* å…³é—­æŒ‰é’® */
  .mermaid-modal-close {
    position: absolute;
    top: 1rem;
    right: 1rem;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    font-size: 2rem;
    line-height: 1;
    cursor: pointer;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* æ§åˆ¶é¢æ¿ */
  .mermaid-modal-controls {
    position: absolute;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 0.5rem;
    align-items: center;
    background: rgba(0, 0, 0, 0.8);
    padding: 0.75rem 1.5rem;
    border-radius: 100px;
    z-index: 10;
    backdrop-filter: blur(8px);
  }

  .mermaid-zoom-btn {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border: 1px solid rgba(255, 255, 255, 0.2);
    background: rgba(255, 255, 255, 0.1);
    color: white;
    font-size: 1rem;
    cursor: pointer;
  }

  .mermaid-zoom-level {
    color: white;
    font-size: 0.875rem;
    font-weight: 600;
    min-width: 50px;
    text-align: center;
    margin: 0 0.5rem;
  }

  .mermaid-modal-body {
    flex: 1;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  /* âœ… æ¨¡æ€æ¡†å­—ä½“ä¹Ÿ clamp(10~14) */
  .mermaid-modal-body svg text,
  .mermaid-modal-body svg .nodeLabel,
  .mermaid-modal-body svg .edgeLabel,
  .mermaid-modal-body svg .label,
  .mermaid-modal-body svg tspan {
    font-size: clamp(10px, 1em, 14px) !important;
    font-family: Arial, sans-serif !important;
  }

  /* å“åº”å¼ */
  @media (max-width: 768px) {
    .mermaid-modal-content {
      width: 100vw;
      height: 100vh;
      border-radius: 0;
    }

    .mermaid-modal-controls {
      bottom: 1rem;
      padding: 0.5rem 1rem;
    }

    .mermaid-zoom-btn {
      width: 32px;
      height: 32px;
      font-size: 0.875rem;
    }

    .mermaid-hint {
      font-size: 0.75rem;
    }
  }
</style>
